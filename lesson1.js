
//------------------------------------------------------------------------------------------Конспект по JavaScript------------------------------------------------------------------------------------------------------

/* Каждая программа — набор команд. В JavaScript команды разделяются точкой с запятой - ; 
   Программа выполняется последовательно, сверху вниз, команда за командой.
   Каждая комнада оперирует переменными. 
   Переме́нная в императивном программировании — поименованная, либо адресуемая иным способом область памяти, адрес которой можно использовать для осуществления доступа к данным.
   Т.е. переменная — название для данных, которое понятно для людей. 

   Переменные могут быть частью операций: сложение(+), вычитание(-), умножение(*), возведение в степень(**), деление(/), остаток от деления(%), увеличение значение на единицу(++), уменьшение значения на единицу(--).
   Более сложные математические операции задаются командой Math ... Например: округление - Math.round(); корень квадратный Math.sqrt() и т.д. Остальные виды операций можно посмотреть в справочнике.

 *Операторы сравнения: > «больше»; <	«меньше»; >= «больше или равно»; <=	«меньше или равно».
 *Операторы равенства: ==	«нестрогое равенство» с приведением типов аргументов; === «строгое равенство»	без приведения типов аргументов; !=	«нестрогое неравенство»	с приведением типов аргументов; !==	«строгое неравенство»	без приведения типов аргументов
  Любые значения внутри проверок приводятся к булеву типу. Все числа кроме 0 — true, при этом 0 — false. Все строки, кроме пустой строки — true, пустая строка '' — false.
 *Логические операторы.
  Оператор && или «логическое И» возвращает true только в том случае, если оба условия, слева и справа от него, возвращают true.
  Оператор || или «логическое ИЛИ» возвращает true если любое из условий слева или справа от него, возвращают true.
  Оператор ! или «логическое отрицание» меняет булево значение выражения справа от него на противоположное.
*/
/*
JavaScript особым образом воспринимает html разметку: элементы здесь не строки, которые мы пишем в HTML-файлах, а объекты. 
При этом каждый объект связан с другими такими же объектами и знает о своём родителе, соседних объектах-элементах, вложенных объектах. В итоге получается древовидная структура, 
которая называется DOM (Document Object Model или объектная модель документа).

В каждом DOM-дереве есть корневой объект, из которого «растут» другие объекты. Он называется document. Этот глобальный объект доступен во всех программах, которые работают в браузере. 
Проще говоря, document — страница, которая содержит все элементы разметки (объекты).
*/


// (--1--)  Переменной можно сделать не только класс, но и тег (например тег <р>), но это будет только первый тег на странице. Находим тег, или класс с помощью команды querySelector.
let paragraph = document.querySelector('p'); // Ищем в document-е тег <p></p>

// 1.1 Чтобы найти пятый параграф в квадратный скобках указываем порядковый номер элемента. Используем querySelectorAll.
let paragraph6 = document.querySelectorAll('p')[5]; // Не забываем что нумерация начинается с нуля. Если не указать порядковый номер, то метод querySelectorAll вернет список (колекцию) элементов <p>
// Этот список похож на массив, но им не является. Он называется псевдомассив и его можно перебирать с помощью цикла for.

// Не обязательно искать элемент во всем документе, в ряде случаев можно осуществлять поиск в отдельном элементе, т.к. поиск по всему документу ресурсоёмкая операция.
let someDiv = document.querySelector('.signup'); // Нашли некий div с классом signup.
let someTitle = someDiv.querySelector('h4');     // Теперь мы можем в этом div-е искать другие элементы, например заголовки с тегом h4.
let someElement = someDiv.querySelector('button.class');  // Можно одновременно указать и HTML элемент и его класс, сделав селектор более специфичным.


// (--2--)  Переменную можно и не искать в документе а создать напрямую, с помощью команды let, var, или const. И присвоить ей любое цифровое или строковое значение.
/* 
Разница между let и var заключается в области видимости. Например если объявить переменную внутри цикла через let, то за пределами цикла её не будет видно, а если через var, то её можно будет использовать дальше.
Иначе говоря все переменные объявленные через var подвержены hoisting-у (всплытию), и их объявление выносится за пределы, функции, цикла или условия в область видимости всего документа. 
Переменные объявленные внутри функции, называются локальными переменными, а объявленные вне - глобальными.
Переменная объявленная через let будет использоваться только внутри цикла, функции или условия и не выйдет за его пределы.
Переменная объявленная через const также не подвержена hoisting-у, но помимо этого значение этой переменной постоянно, и не может изменятся далее.

Hoisting "поднимает" только объявление переменной, но не инициализацию. Если вы используете переменную, объявленную и проинициализированную после ее использования, то значение будет undefined.
Т.е. JaveScript будет знать о существовании переменной, но значение переменной будет неопределено.
И если уже быть совсем точным, то hoisting учит, что объявление переменной, или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. 
На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.
*/
const count = 100500; // Переменная отсутствует на странице в браузере и приведена для примера ниже в 4-ом пункте.
let sometext = '6. Строка текста объявленная в скрипте, заменившая собой оригинальный текст шестого параграфа';


// (--3--)  Переменную найденную в документе можно переписать, присвоить ей любое строчное или числовое значение, через метод textContent, или innerHTML.
paragraph.textContent = '1. Используем свойство textContent, чтобы изменить содержимое параграфа + число ' + 77 + ' (проверка конкатенации)';
// В примере выше использована конкатенация - объединение строковых данных и числовых.
// paragraph.innerHTML = 'Используем второй метод изменения текстового содержимого элемента с помощью свойства innerHTML';

// (--4--)  Переменой можно присвоить значение, взятое из другой переменной. Например переменной, которая соответствует тегу <input type="number" class="input1">.
let input1 = document.querySelector('.input1');
count.textContent = input1.value; // Для переменной связанной с тегом input используем свойство value. !!!
paragraph6.textContent = sometext;  // Напрямую присвоили значение переменной sometext пятому параграфу. 
// В результате текст пятого параграфа изменился на текст содержащийся в переменной sometext.


// (--5--)  Атрибут data- и свойства dataset и innerHTML.
// Если у тега <input> или <textarea> есть атрибут value, то для других тегов можно использовать атрибут data-, присваивать ему любое имя и содержание данного атрибута уже добавлять куда нужно.
let knopka3 = document.querySelector('.knopka3'); // Находим элемент в которой находится атрибут data с именем -des-cription.
let div1 = document.querySelector('.div1'); // Объявляем переменную в которую мы будем записывать содержание data-des-cription.
knopka3.onclick = function () { // При нажатии кнопки содержимое атрибута data, хранящееся в этой же кнопке, будет выводится в div с классом div1.
   div1.textContent = knopka3.dataset.desCription; // Если имя атрибута состоит из нескольких слов и в нём есть дефисы (как в нашем случае), то в JavaScript его записывают в «верблюжьем» стиле.
   // div1.innerHTML = knopka3.dataset.desCription; - Добавлять содержимое в HTML-элемент через JavaScript можно с помощью свойства innerHTML
}

// (--6--)  Любой переменной можно присвоить класс, через метод classList.add. При этом можно указывать не только класс, но и переменную, которой соответсвует какой-либо класс.
paragraph.classList.add('plus-one');


// (--7--)  Затем удалить этот класс, через метод classList.remove
paragraph.classList.remove('newclass');


// (--8--)  Можно включать-выключать класс (например при повторных нажатиях на кнопку), используя метод classList.toggle.
paragraph.classList.toggle('plus-one'); //пример работы встроен в обработчик событий onclick ниже.


// (--9--)  Можно проверить наличие класса у переменной используя метод classList.contains.
paragraph.classList.contains('newclass');


// (--10--) Свойство length - позволяет узнать длину текстового содержимого переменной, а именно количество символов в тексте, включая пробелы.
let text = 'Сто - пицот символов!';
console.log(text.length);


// (--11--) Можно создать новый элемент в документе (на html страницу) с помощью метода createElement. Для начала создаём новый элемент как переменную.
let div0 = document.createElement('div');
div0.classList.add('div0'); // Добавили созданном элементу класс, чтобы в дальнейшем применять к нему стили.


// (--12--) Можно добавить созданный элемент выше элемент (как собственно и любой другой) на страницу с помощью метода append.
let aside = document.querySelector('aside div'); // Нашли элемент куда будем добавлять созданный выше элемент <div>.
aside.append(div0); // Тег div добавился внутрь тега aside, далее этим же методом добавим в div0 текстовое содержание.
div0.append(knopka3.textContent); // Добавили textContent кнопки с классом knopka3 внутрь тега div0.
// Таким образом метод append позволяет добавлять на страницу не только html теги, но и их содержимое. 
// Если нужно добавить элемент в конец родительского элемента, то используется метод appendChild.
// Если нужно добавить картинку на страницу, то помимо тега <img> нужно еще указать атрибут src с ссылкой на расположение картинки. Делается это следующим образом:
var picture = document.createElement('img');               // Создали тег <img> 
picture.src = 'images/somepicture.jpg';                    // Добавили атрибут src с сылкой на с ссылкой на место расположнение картинки.
picture.alt = 'Описание картинки, если она не загрузится'; // Точно также можно добавить и атрибут alt с альтернативным текстом.

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/* Виды условных конструкций. Действие в условной конструкции может быть не одно, а несколько. Примеры условных конструкций есть в коде ниже.

1) Условие: 
   if (условие) {действие;} - Если выполняется условие, то выполняется и действие.
2) Условие с альтернативным действием: 
   if (условие) {действие;} - Если выполняется условие, то выполняется и действие.
   else {другое действие;} - Иначе, если условие не выполнилось, то выполняется другое действие.
3) Вложенные условия в конструкции if:
   if (условие1) { - Если выполнилось условие1, то только тогда проверяется условие2, 
   if (условие2) {действие;} и если условие2 выполнилось, то выполняется действие. Этим действием может быть третье условие и т.д.
   }
4) Вложеные условия в конструкции else:
   if (условие1) {действие;} - Если выполняется условие1, то выполняется и действие.
   else {действие; - Иначе, если условие1 не выполнилось, то выполняется другое действие, 
   if {действие} а также проверяется вложеное условие, и если оно выполняется, то выполняется второе действие.
   }
5) Ряд условий
   Конструкция else if, позволяет добавить  альтернативную ветку c условием:
   if (первое условие) { Инструкции выполнятся, если истинно первое условие} 
   else if (условие №2) { Инструкции выполнятся, если истинно второе условие}
   else if (условие №3) { Инструкции выполнятся, если истинно третье условие} и т.д.
   else (последнее условие, его можно не указывать) { Инструкции выполнятся если не одно из предыдущих условий не вернуло true}
   Веток else if в условной конструкции может быть сколько угодно. Но чем их больше, тем запутаннее получается код.
*/



//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Функции в JavaScript - посути обработчики событий, реагируют на действия пользователей, - на нажатия, скролл, выбор и т.д.

// (--13--)  Функция onclick - срабатывает при нажатии на кнопку.
// Объявляем переменные с которыми будем работать. 
let likeButton = document.querySelector('.like-button'); // Кнопка на которую будем кликать.
let likesNumber = document.querySelector('.likes-number'); // Счётчик лайков, числовое значение которого мы будем изменять.

likeButton.onclick = function () {  // Объявляем функцию: сделать нижеследующие действия при клике на кнопку.
   if (likeButton.classList.contains('plus-one')) // Условие: ЕСЛИ кнопка содержит в себе класс plus-one, 
   { likesNumber.textContent--; } // то уменьшаем числовое значение переменной likesNumber на одну единицу.
   else // ИНАЧЕ - если кнопка НЕ содержит в себе класс plus-one,
   { likesNumber.textContent++; } // то увеличиваем числовое занчение переменной likesNumber на одну единицу.
   likeButton.classList.toggle('plus-one'); // Встраиваем в функцию onclick переключатель классов.  
};
// Условная конструкция if-else может содержать только один элемент if (в зависимости от поставленной задачи).


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (--14--) Функция onsubmit - срабатывает при отравке формы.
//Объявляем переменные с которыми будем работать.
let form = document.querySelector('.comment-form'); // В отличии от функции onclick, данная функция привязывается к форме, а не к кнопке, на которую мы нажимаем
let input = document.querySelector('.input'); // Объявляем поле input, т.к. из него мы будем брать введенные данные.
let charCounter = document.querySelector('.char-counter'); // Объявляем счётчик символов, который будет испльзоваться в данной функции и в функции ниже.
let section2 = document.querySelector('section:last-child'); // Объявляем место куда будем добавлять комментарии.

form.onsubmit = function (evt) { // Объявляем функцию: при отправке формы сделать ниже следующее.
   evt.preventDefault(); // Отменяет отправку формы на сервер, т.к. его нет.
   let span = document.createElement('span'); // Создаём элемент <span>.
   span.classList.add('comment'); // Добавляем к нему класс.
   span.textContent = input.value;  // Записываем в <span> данные которые мы ввели в поле ввода <input>.
   section2.append(span); // Добавляем готовый тег <span> с введёнными данными на страницу внутри тега <form>. 
   //Вместо раздела <form> может быть любой другой раздел на странице, например <main>, только его надо заранее прописать в переменную, перед функцией.
   input.value = ''; // Очистка поля ввода, чтобы пользователь по ошибке не отправил форму несколько раз. Для этого в его свойство value записывают пустую строку.
   charCounter.textContent = 0; // Обнуляем счётчик символов, который используем в функции oninput, ниже.
};


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (--15--) Функция oninput - срабатывает при вводе текста (символов).
let subButton = document.querySelector('.sub');
let commentForm = document.querySelector('.comment-form');

// Находим поле которое будет отображать количество вводимых символов.
input.oninput = function () { // Объявляем функцию которая будет считать вводимые символы.
   charCounter.textContent = input.value.length; // Поле отображающее количество введенных символов, выдает данные из поля ввода с классом input, которое было объявлене в функции onsubmit.
   if (input.value.length > 50) { // Если значение поля ввода превышает по длине 20 символов, то
      commentForm.classList.add('warning'); // форме добавляется класс warning и
      subButton.disabled = true; // кнопка отправки формы блокируется, для этого используется свойство disabled (оно активируется при значении true и отключается при значении false).
   }
   else { // в ином случае, когда количество символов не превышает допустимых пределов, то
      commentForm.classList.remove('warning'); // с формы удаляестся класс warning и 
      subButton.disabled = false; //кнопка отправки формы, разблокируется.
   }
};


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (--16--) Функция onscroll - срабатывает при прокрутки страницы.
let upButton = document.querySelector('.up-button');
window.onscroll = function () { // Страница браузера идёт как переменная window, поэтому её не надо объявлять.
   console.log(window.pageYOffset); // Величина вертикальной прокрутки (в пикселях) хранится в свойстве pageYOffset.
   console.log(window.pageXOffset); // Величина горизонтальной прокрутки (в пикселях) хранится в свойстве pageXOffset.
   if (window.pageYOffset > 300) { // Если величина вертикальной прокрутки больше 50px, то
      upButton.classList.add('shown'); // Кнопке добавляется класс shown и она появляется на странице в браузере
   }
   else { // Иначе, когда величина вертикальной прокрутки меньше 50px, то
      upButton.classList.remove('shown'); // У кнопки удаляется класс shown и она пропадает со страницы
   }
};
upButton.onclick = function () { // При клике на кнопку, браузер автоматически должен проскроллить страницу вверх используя метод scrollTo.
   window.scrollTo(0, 0); // В скобках указаны координаты (х и у), куда нужно проскроллить страницу. 
};// В зависимости от величины указанных координат браузер может скроллить страницу в любом наравлении: вверх-вниз; вправо-влево.


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (--17--) Функция onchange - срабатывает при выборе как-либо значения в чекбоксе, радиокнопки, или из выпадающего списка тега <select></select>.
let articles = document.querySelectorAll('.article'); // Находим все интересующие нас параграфы с классом article.
let filter1 = document.querySelector('.filter1'); // Находим фильтр с помощью которого будем ВЫБИРАТЬ нужные нам параграфы.
let filter2 = document.querySelector('.filter2'); // Находим фильтр с помощью которого будем  нужные нам параграфы.
let popUp = document.querySelector('.popUp'); // Находим всплывающее окно,в котором будет отображаться текст

filter1.onchange = function () { // Объявляем функцию onchange,
   for (let article of articles) { // для каждого article из всех articles,
      if (article.dataset.category === filter1.value) { // если значение атрибута data- у какого-то артикля совпадает(===) со значением выбранного фильтра, то
         article.classList.add('highlight'); // артиклю присваивается класс highlight.
      } else { // Иначе, когда значение атрибута data- у какого-то артикля не совпадает со значением выбранного фильтра, то
         article.classList.remove('highlight'); // у артикля удаляется класс highlight.
      } // !!! В цикл for можно добавить несколько условных конструкций, так же условия можно вкладывать в другие условия !!!
      if (filter1.value === 'games') { // если значение фильтра равно games
         popUp.classList.add('opened'); // артиклю присваивается класс opened.
      }
   }
};

// Та же самая функция onchange, но направленная не на выделение выбранного параграфа, а на УДАЛЕНИЕ не выбранных параграфов.
filter2.onchange = function () { // Объявляем функцию onchange,
   for (let article of articles) { // для каждого article из всех articles,
      if (filter2.value !== article.dataset.category && filter2.value !== 'all' && filter2.value !== 'games') { // ЕСЛИ значение атрибута data- у какого-то артикля НЕ совпадает(!==) со значением выбранного фильтра И
         article.classList.add('hidden'); // значение фильтра не равно all, то такие артикли скрываются с помощью присвоения класса hidden.
      } else { // ИНАЧЕ когда значение фильтра равно значению data- атрибута, то
         article.classList.remove('hidden'); // класс hidden удаляется, А ТАКЖЕ кроме удаления класса hidden
         if (filter2.value === 'games') { // если значение фильтра равно games
            popUp.classList.add('opened'); // артиклю присваивается класс opened.   
         }
      }
   }
}

let closeButton = document.querySelector('.close-button'); // Программируем кнопку, на закрытие всплывающего окна.
closeButton.onclick = function () {                        // Функция onclick удаляет класс opened.
   popUp.classList.remove('opened');
}
/* Чтобы объединить две части условия, используем логическое И. Оно обозначается двойным амперсандом — &&.
Логическое И возвращает true, только если обе части условия возвращают true. Если хотя бы одна из частей вернёт false, то условие целиком также будет считаться ложным.
Логическое ИЛИ обозначается двумя вертикальными чертами || и возвращает true, если хотя бы один из операндов возвращает true.
*/


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (--18--) Кроме вышеперечисленных событий существуют и другие события. Полный список возможных Web событий приведён здесь: https://developer.mozilla.org/en-US/docs/Web/Events.
// Обрабатываются события функцией addEventListener.
let htmlElement = document.querySelector('footer'); // Указывается html элемент, события по которому будем отслеживать (кнопка, див, спан, что угодно.)
htmlElement.addEventListener('click', function (evt) {  // Указывается тип события: focus, error, submit, copy, click, pause, play и множество других.
   evt.preventDefault(); // Отменяем действие по умолчанию.
   // Инструкции
});
// Второй параметр addEventListener — функция-обработчик, в ней записаны инструкции, которые выполнятся, только когда произойдёт событие.
// Следует обратить внимание, что мы передаём функцию, а не её вызов. Если мы вызовем функцию, код из этой функции выполнится сразу и больше не сработает. 
// А нам нужно, чтобы код выполнился асинхронно — в момент, когда произойдёт событие.
/* 
Некоторые элементы страницы имеют действия по умолчанию. Их ещё называют дефолтными действиями. 
Например, клик по кнопке отправления формы вызывает отправку данных этой формы на сервер, а при клике по ссылке браузер переходит по этой ссылке.
Дефолтные действия можно отменять при необходимости, в этом поможет объект event.
Объект event — параметр функции-обработчика. Он всегда передаётся браузером в эту функцию в момент наступления события. Этот объект содержит много полезных свойств и методов, в частности метод, 
который отменяет действие по умолчанию: preventDefault()
Чтобы использовать свойства и методы объекта event, достаточно указать этот объект параметром функции-обработчика и написать инструкции. Остальное сделает JavaScript. 
Среди некоторых разработчиков принято называть этот параметр сокращённо — evt.
*/


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (--19--) Обработка нажатия клавиш клавиатуры.
// У события «нажатие на клавишу» есть специальное название — keydown. Такое событие срабатывает при нажатии на любую клавишу. Обратите внимание, слушать это событие можно только на элементах, 
// которые имеют состояние фокуса: поля ввода, кнопки, элементы с атрибутом tabindex, документ. При нажатии фокус должен находиться на соответствующем элементе.
document.addEventListener('keydown', function (evt) { // Особое внимание на то что событие отслеживается по всему документу, чтобы не ловить фокус на отдельном элементе, поэтому в самом начале указан document.
   if (evt.keyCode === 27) {
      console.log('Я нажал ESC');
   }
});

// Мы говорили выше, что у объекта события !event! есть много полезных свойств. Например, тип события, введённый символ, координаты курсора в момент наступления события и многое другое. 
// В том числе и код клавиши, которую нажал пользователь. Это свойство называется keyCode.
// С помощью этого свойства каждую клавишу можно определить по коду. Например, у Enter код 13, а у ESC — код 27. Эти номера универсальны и одинаковы в любой раскладке. 
// Найти код любой клавиши можно здесь: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode.



//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// (--20--) Изменение стилей элементов с помощью JS обращением напрямую к свойству style.
// Раньше, чтобы изменить внешний вид элемента, мы использовали классы. Но когда вариантов для изменения того или иного параметра слишком много, создавать множество классов, не рационально. 
// Изменять стили элемента можно напрямую, не присваивая класс с нужными нам параметрами, а напрямую меняя параметры элемента с помощью свойства style. После него через точку указывают то CSS-свойство, которое нужно изменить.
let longread = document.querySelector('.longread');                    // Объявляем переменную, у которой будем менять параметры. Это будет параграф с классом .longread
let colorSetting = document.querySelector('.color-setting');           // Менять будем цвет текста, значение цвета будем брать из атрибута value соответствующего селектора.
let backgroundSetting = document.querySelector('.background-setting'); // Менять будем цвет фона, значение цвета будем брать из атрибута value соответствующего селектора.
let sizeSetting = document.querySelector('.size-setting');             // Менять будем размер шрифта текста, значение размера будем брать из атрибута value соответствующего селектора.
let pixels = document.querySelector('.pixels');                        // Объявляем переменную, в которой будет отображаться размер шрифта.

colorSetting.onchange = function () {                        // Функция onchange реагирует на изменение осуществляемые пользователем. При выборе пользователем цвета текста... 
   longread.style.color = colorSetting.value;                // ... цветовой стиль текста становится таким каким он прописан в атрибуте value у выбранного пользователем пункта.
};
backgroundSetting.onchange = function () {                   // Функция onchange реагирует на изменение осуществляемые пользователем. При выборе пользователем цвета фона... 
   longread.style.backgroundColor = backgroundSetting.value; // ... цветовой стиль фона становится таким, каким он прописан в атрибуте value у выбранного пользователем пункта. 
   //В JavaScript нельзя использовать дефисы в названиях свойств, вместо этого для разделения слов используется «верблюжий» стиль, от же camelCase. Например: background-color(CSS) = backgroundColor(JS).
};
sizeSetting.oninput = function () {                    // Функция oninput в отличии от предыдущей вносит изменения на страницу на каждом этапе изменения, а не только на финишном.
   pixels.textContent = sizeSetting.value;             // В элементе с классом .pixels одномоментно отображаются изменения происходящие при изменинии значения ползунка. Выводится размер применяемого к тексту шрифта.
   longread.style.fontSize = sizeSetting.value + 'px'; //Меняется сам текст - атрибут текста font-size становится равным значению(value) ползунка. Меняется встроенный атрибут шрифта style="font-size:sizeSetting.value px"
};

// С помощью JavaScript и встроенного атрибута "style" можно не только задавать параметры элементов. Но и получать эти параметры, если они уже заданы в HTML документе.
// Чтобы получить все стили, которые применяются к элементу, используйте метод: getComputedStyle.
let computedStyle = getComputedStyle(document.body);
// сейчас мы можем прочитать отступ и цвет у элемента body/
// alert( computedStyle.marginTop ); // 8px  -- команда закомментирована, ибо функция alert выскакивает каждый раз когда меняется код.


// Изменять с помощью скрипта можно не только встроенный атрибут style, но и атрибут type у соответствующих тегов.
let password = document.querySelector('.password'); // Переменная отвечающая за поле ввода пароля
let showPassword = document.querySelector('.show-password'); // Переменная отвечающая за чекбокс показа пароля.
let securityBar = document.querySelector('.security-bar'); // Переменная отвечающая за полоску сложности пароля.

showPassword.onchange = function () { // Функция изменения при смене значения чекбокса.
   if (showPassword.checked) {
      password.type = 'text'; // Если в чекбоксе стоит галочка, то тип поля ввода меняется на "text" и пользователь может видеть вводимый пароль.
   } else {
      password.type = 'password'; // В ином случае тип поля ввода меняется на "password" и пароль скрытвается за звёздочками.
   }
};

password.oninput = function () {                      // Функция ввода отслеживает изменение длины пароля
   let passLength = password.value.length;            // Значение длины пароля в дальнейшем понадобится не однократно, поэтому чтобы не писать много кода, данное значение делаем переменной.
   securityBar.style.width = passLength * 6 + '%';    // Длина полоски сложности равна количеству введёных символов в поле ввода пароля, умноженое на коэффициент 6(может быть любым) и выраженная в процентах.
   if (passLength <= 4) {                             // Если длина пароля меньше 4 символов, то...
      securityBar.style.backgroundColor = 'red';      // ... полоска сложности пароля красная.
   } else if (passLength > 4 && passLength <= 9) {    // ИНАЧЕ, ЕСЛИ  количество введёных символов от 4 до 8, то...
      securityBar.style.backgroundColor = ' #ff7a24'; // полоска сложности пароля тёмно-оранжевая.
   } else if (passLength > 9 && passLength <= 14) {   // ИНАЧЕ, ЕСЛИ  количество введёных символов от 4 до 8, то...
      securityBar.style.backgroundColor = ' #ffbf00'; // полоска сложности пароля светло-оранжевая.
   } else {                                           // Если все предыдущие условия не выполнились в виду того что количество введёных символов превысило цифру 14
      securityBar.style.backgroundColor = '#bfff00';  // То цвет полоски ввода пароля становится зелёным.
   }
};



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Циклы в JavaScript. Цикл — это конструкция, которая позволяет выполнить код несколько раз. В JavaScript существуют разные циклы.
// Циклы можно встраивать в условия, в функции и наоборот. Условия можно вложить в цикл, или функции вложить в цикл, как это показано в примерах ниже.


// Цикл for.
let i = 0; // Объявляем переменную.
for (i = 0; i <= 10; i++) {  // Задаём условие: начальное значение переменной равно 0; пока переменная меньше 10 увеличивать её на единицу.
   document.write(i + ' '); // Выводим последовательность чисел от 0 до 10 на страницу
}

// Тот же самый цикл, но переменную объявляем внутри цикла.
for (let a = 5; a <= 20; a += 2) {  // Задаём условие: начальное значение переменной равно 5; пока переменная меньше 20 увеличивать её на два.
   if (a % 3 == 0) continue; // Пропускаем в нашем ряду все числа у которых отстаток от деления на три равен нулю.
   if (a == 17) break; // Принудительно останавливаем цикл при достижении переменной цифры 17.
   document.write('№' + a + ' '); // Выводим последовательность чисел от 5 до 17 на страницу
};

// Цикл в условиями внутри. (На примере задачи с расчетом общей зарплаты)
let days = 7;            // Предположим мы работаем 7 дней, с начала месяца.
let oddDays = 100;       // По нечетным числам мы получаем 100$.       
let evenDays = 50;       // По четным числам мы получаем 50$.
let total = 0;           // Всего зарaботано изначально 0
for (let day = 1; day <= days; day++) { // Для каждого дня с 1го до последнего (7) при подсчете каждого дня (+1)
   if (day % 2 === 0) {  // Если номер дня делится на 2 без остатка, т.е. остаток от деления равен нулю, то день четный и тогда...
      total += evenDays; // ... ко всей зарплате, которая на тот момент заработана прибавляется число находящееся в переменной evenDays.
   } else {              // Иначе, если номер дня нечётный, то ...
      total += oddDays;  // ... ко всей зарплате, которая на тот момент заработана прибвляется число находящееся в переменной oddDays.
   }
   document.write('День' + day + '-' + total + '$ ');
}


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Цикл for of
let paragraph5 = document.querySelector('.paragraph5'); // Объект который будет менятся (будем переключать ему классы).
let knopki = document.querySelectorAll('.knopka2'); // Находим ВСЕ! кнопки у которых будет одно функциональное назначение. Здесь нужно быть внимательным и использовать querySelectorAll.
for (let knopka of knopki) {  // Внутри цикла объявляем переменную, которая будет являтся элементом общего массива кнопок. 
   knopka.onclick = function () { // Для каждой кнопки из всех 3 кнопок присваиваем одинаковую функцию. На самом деле кнопок может быть не 3, а гораздо больше.
      paragraph5.classList.toggle('newclass'); // При клике по любой из кнопок массива будет выполнятся переключение классов.
   };
} // Данный цикл позволяет написать один общий код для всех кнопок, сколько бы их не было.



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Цикл while - применяется в тех случаях когда количество повторений цикла, заранее не известно. И применяется ПОКА цель не будет достигнута.
// Рассмотрим логику данного цикла на примере игры в дартс.

var score = 16; // Переменная в которую записываем очки после каждого броска игрока.
var totalScore = 0; // Переменная в которой хранится общее количество очков, изначально равно нулю.
var victoryPoints = 100; // Переменная в которой хранится количество очков необходимое для победы.
var misses = 0; // Переменная в которой храниться количество промахов.
while (totalScore < victoryPoints) { // Цикл продолжается до тех пор пока общее количество очков, не превысит значение записанное в переменную victoryPoints(100).
   if (misses >= 3) { // Цикл прервётся, командой "break" если количество промахов будет равным трём.
      break;
   }
   //score = player.getScore(); Получаем данные от броска игрока. При попадание количество очков зависит от зоны попадания. При промахе, получаем "-1".
   // Данная команда закомментирована, т.к. у нас нет внешнего источника данных, из которого мы будем брать количество очков при броске.
   if (score < 0) {           // Если после броска количество очков отрицательно, т.е. равно "-1", что соответствует промаху, то...
      console.log('Промах!'); // ... выводим в консоль слово Промах и ...
      misses++;               // ... и записываем один промах игроку в переменную misses.
   } else {                   // Иначе, если игрок не промахнулся, то получаем количество очков зависящее от зоны попадания и ...
      totalScore += score;         // ... записываем очки в переменную хранящаю общее количество очков.
      console.log('Результат броска: ' + score); // Выводим в консоль результат броска.
   }
}
// По завершении цикла, а цикл завершается в двух случаях: если общее количество очков больше 100, или количество промахов больше либо равно трём.
if (totalScore >= victoryPoints) { // Выводим результат, в зависимости от причины отстановки цикла.
   console.log('Победа! Очков: ' + totalScore + ', промахов: ' + misses)
} else {
   console.log('Проигрыш. Очков: ' + totalScore + ', промахов: ' + misses)
}


// Цикл на вычисление, является ли число пaлиндромом.
// Сложность задачи заключается в том чтобы развернуть заданное число зеркально, а затем сравнить его с изначальным.
var poly = 1221;           // Задаем число, которое будет проверятся, является ли оно пaлиндромом.
var inversia = 0;          // Инвертированное число будет записываться в данную переменную, изначально равно нулю
var isPalindrome = false;  // По умолчанию инвертированное число не является полиндромом.
var number = poly;         // Создаём переменную, которая будет менятся в ходе вычисление, изначально она равна задаваемому числу.

while (number >= 1) {                  // ПОКА номер больше или равен 1, цикл продолжается.
   var remnant = number % 10;          // Создаем в теле цикла переменную, которая вычисляетм остаток от деления на 10.
   inversia = inversia * 10 + remnant; // С помощью данной формулы, будем осуществлять инверсию заданного числа, постепенно увеличивая его разрядность в 10 раз.
   number = (number - remnant) / 10;   // С помощью данной формулы будем уменьшать разрядность заданного числа в 10 раз, пока не дойдем до нуля.
}
// Условие, которое сравнивает заданное число с инвертированным.
if (inversia === poly) { // ЕСЛИ числа совпадают, т.е. равны друг другу, то значит это пaлиндром.
   isPalindrome = true;
} else {                 // ИНАЧЕ, это не пaлиндром.
   isPalindrome = false;
}



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Массивы.
/* Когда переменных становиться слишком много их объединяют в массив.
   Массив — тип данных, который представляет собой список элементов, у каждого из которых есть свой порядковый номер.
   В массиве можно хранить любые данные: строки, булевы значения, числа, объекты и даже другие массивы.
   
   Нумерация элементов массива начинается с нуля, поэтому порядковый номер (индекс) первого элемента равен нулю.
   В качестве индекса можно использовать переменную.
   Используйте команду [].length, чтобы узнать длину массива (сколько в нём элементов). С её помощью можно получить последний элемент массива.
*/

var arr1 = [1, 2, 3, 4, 5];
var index = 3;                      // По умолчанию выбран 3 элемент массива(цифра 4), но может быть любой другой.
console.log(arr1[0]);               // Первый элемент массива, под индексом ноль.
// Выведет в консоль: 1
console.log(arr1[index]);           // Индекс равен 3, т.к. мы его задали при объявлении переменной.
// Выведет в консоль: 4
console.log(arr1.length);           // Длина массива, а именно количестово элементов в массиве(5 элементов).
// Выведет в консоль: 5
console.log(arr1[arr1.length - 1]); // Из длины массива вычитаем единицу, получаем последний элемент массива (5-1=4).
// Выведет в консоль: 5
// Как видно из примеров выше, чтобы обратится к элементу массива, не обязательно явно указывать номер ячейки. В квадратных скобках может быть любое выражение, которое в последствие преобразуется в цифру.

// Для массивов внутри массивов следующий синтаксис:
var array = [["Балтийское", "Эстония", "Силламяэ"], ["Охотское", "Россия", "Охотск"], ["Жёлтое", "Китай", "Бэйдайхэ"]]
console.log(array);        // Выведет весь массив.
console.log(array[0]);     // Выведет ["Балтийское","Эстония","Силламяэ"] - т.е. элемент под индесом 0
console.log(array[0][0]);  // Выведет "Балтийское" - т.е. элемент в под индексом ноль во вложенном массиве.


//Массивы можно перебирать в циклах. Например, цикл ниже выводит элементы массива в консоль по очереди и прекращает свою работу, когда i станет равно длине массива.
var arr2 = ['Строковые и', 'числовые данные ', 'очередного', 'массива', 'а также', 'числа четыре и пять', 4, 5];

for (let i = 0; i < arr2.length; i++) {  // Перебор массива циклом for.
   console.log(arr2[i]);
}
for (let someData of arr2) {             // Перебор массива циклом for of.
   console.log(someData);
}


//Запись в массив и команда PUSH. Запись происходит так же, как чтение, через квадратные скобки. Альтернативный способ последовательная запись командой push.
var arr3 = [];              // Создали пустой массив.
arr3[0] = 100500;           // Записали в первую ячейку цифру 100500 - индекс ячейки 0.
arr3[1] = 777888;           // Записали во вторую ячейку цифру 777888 - индекс ячейки 1.
arr3[arr3.length] = 'Boom!' // При такой записи, сразу за последней ячейкой массива будет создаваться новая ячейка и новые данные будут записываться в неё. В данном случае записываем в ячейку [2]
// Команда "length" позволяет узнать длину массива. Длина массива выражается в числе ячеек, которые содержит в себе массив. Например если в массиве arr3 четыре ячейки, то length = 4.
// Так же для записи в массив можно использовать команду "push". Пишем название массива, в который мы хотим "запушить" данные, затем команду push и в скобках сами данные, которые запишутся в ячейку массива.
arr3.push('Команда push также, как и запись выше, последовательно записывает данные в конец массива.'); // Записываем в ячейку с индексом [3]
arr3.push('Ещё пара слов'); // Записываем в ячейку с индексом [4]
console.log(arr3);          // Вывели к консоль массив.
console.log(arr3.length);   // Вывели к консоль длинну массива.
console.log(arr3[4].length);// Команда "length" также позволяет узнать длину строки хранящейся в конкретной ячейке, включая пробелы.


// Шифровщик на двух массивах. В первом массиве хранятся буквы алфавита. Во втором массиве зашифрованное сообщение, где цифры в ячейках массива ссылаются на номер ячейки первого массива с нужной буквой.
// Алфавит
var symbols = ['А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П', 'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я', 'а',
   'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п', 'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ', '.', ',', '—', '!'];
// Закодированное сообщение
var encodedMessage = [18, 38, 46, 62, 66, 50, 33, 41, 66, 49, 48, 38, 58, 62, 68, 66, 48, 37, 42, 47, 66, 50, 33, 41, 66, 49, 48, 51, 49, 42, 67];
// Раскодированное сообщение
var decodedMessage = '';
for (let i = 0; i < encodedMessage.length; i++) { // Перебираем все ячейки с первой до последней в массиве зашифрованного сообщения. Данные из этих ячеек вписываем как индекс ячейки первого массивы(с алфавитом).
   decodedMessage += symbols[encodedMessage[i]]   // На каждой итерации букву из ячейки первого массивы, с соответствующим индексом добавляем конкатенацией в переменную decodedMessage.
} console.log(decodedMessage);                    // Выводим расшифрованное сообщение в консоль.


// Команда indexOf(). Чтобы проверить наличие строки в элементе массива, используется команда indexOf(). Данная команда выдает индекс положения элемента внутри ячейки массива.
var usersData = ['Виталий Иванович', 'Иннокентий Петрович', 'Александр Александрович', 'Игорь Олегович', 'Евгений Петрович', 'Игнат Денисович', 'Сергей Александрович', 'Семён Петрович'];
var query = 'Александрович'; // Переменная в которой записан поисковый запрос. В данном случае ищем в массиве те ячейки в которых содержится данное отчество.
var matchingUsers = [];      // Создаем второй массив в который запишем номера ячеек первого массива, в котором содержатся данные, которые мы ищем.
var totalQueryUsers = 0;     // Общее количество найденных в массиве пользователей.
for (let i = 0; i < usersData.length; i++) { // Команда indexOf() возвращает индекс, на котором начинается подстрока, а если этой подстроки нет, возвращает -1. 
   if (usersData[i].indexOf(query) > -1) {   // Т.е. буквы внутри ячеек массива со строковыми данными также имеют свою нумерацию, или индексы. Для массива usersData вернет - -1; -1; 11; -1; -1; -1; 8; -1.
      matchingUsers.push(i);                 // Когда условие находит ячейку в которой содержится нужная нам подстрока, нужное нам слово, то номер этой ячейки записывается во второй массив.
      totalQueryUsers++;                     // Всякий раз когда мы находим нужное нам слово, счетчик найденых слов увеличивается на единицу.
   }
}
console.log(matchingUsers);  // Данные второго массива выводятся в консоль.
// Также команда indexOf() может искать не внутри самой ячейки, а внутри массива ячейку и выдавать индекс ячейки массива. 
console.log(usersData.indexOf('Евгений Петрович')); // Выведет в консоль цифру 4.



// Сортировка массива. 
// Массив с числами numbers сортируется по возрастанию элементов. На каждой итерации мы сравниваем minValue с остальными элементами массива. Если какой-то из них окажется меньше, чем minValue, 
// он запишется в minValue, перезаписав старое значение, и переместится в начало массива. Переменная swap — вспомогательная переменная, с помощью, которой мы можем поменять элементы местами.
var numbers = [12, 3, 7, 9, 10, 5];
// Сортировка идёт на возрастание, но если в дочернем цикле, в условии знак сравнения поменять с меньше"<" на знак больше">", то сортировка будет идти по убыванию.
for (let i = 0; i <= numbers.length - 2; i++) { // Цикл в цикле, родительский цикл заканчивается на предпоследнем элементе, т.к. последний элемент уже не с чем сравнивать.
   // Родительский цикл содержит в себе другой цикл, который сравнивает все элементы массива с нулевой ячейкой(0) и только после этого переключается на следующую ячейку с индексом (1). После этого дочерний цикл
   // снова ищет в массиве самое маленькое число из оставшихся и записывает его ячейку с индексом(1). Далее родительский цикл переключается на ячейку с индексом (2) и т.д.
   var minValue = numbers[i];                          // Переменная хранящая текущее минимальное значение из всех обнаруженных в ячейках массива, на данный момент. Изначально записано значение нулевой ячейки(12).
   for (var j = i + 1; j <= numbers.length - 1; j++) { // Начинаем цикл со стартовой ячейки j которая на единицу больше нулевой ячейки. Прибавляя к нулевой ячейке разные цифры мы можем менять точку старта.
      if (numbers[j] < minValue) { // ЕСЛИ текущее значение в массиве меньше значения записанного в minValue, то...
         minValue = numbers[j];    // ... в minValue записываем текущее значение ячейки массива, 
         var swap = numbers[i];    // из нулевой ячейки копируем данные в переменную swap,
         numbers[i] = minValue;    // и после этого записываем в нулевую ячейку новое минимальное значение из переменной minValue,
         numbers[j] = swap;        // а в текущую ячейку массива заносим данные которые до этого были в нулевой ячейки, и были помещены на временное хранение в переменную swap.
      }
   }
}
console.log(numbers);
// Выведет: [3, 5, 7, 9, 10, 12];



//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// Объекты.
// Объект — тип данных, который хранит в себе информацию в виде пар «ключ-значение». Если массив — нумерованный список, где каждый элемент имеет свой порядковый номер, то объект — список, 
// в котором каждый элемент сопоставлен со своим ключом и порядок совсем неважен. Ниже показан синтаксис, при записи объекта.
var cat = {
   name: 'Мяут',
   // Добавили новое свойство, где name — ключ, 'Мяут' — значение
   age: 5
   // Новое свойство. Ключ — age, значение — 5
};


// Чтобы получить значение свойства, к нему надо обратиться через точку ! объект.ключ ! Такая запись называется точечной нотацией и возвращает значение свойства объекта, если такое свойство есть. 
// В противном случае вы получите undefined, то есть ничего. На практике это выглядит так:
console.log(cat.name); // Выведет в консоль: Мяут
console.log(cat.age); // Выведет в консоль: 5
console.log(cat.color); // Выведет: undefined. Такого ключа в объекте нет
// Обращаться к свойствам объектов можно не только с помощью точки , но и с помощью квадратных скобок. Такая запись называется скобочной нотацией.
// Скобочная нотация намного гибче точечной. Например, вы можете прочитать из объекта свойство, название которого записано в переменную:
var name = 'Мяут';
var catsFavoriteFood = { 'Мяут': 'рыба' };
console.log(catsFavoriteFood.name); // Выведет в консоль: undefined
console.log(catsFavoriteFood[name]); // Выведет в консоль: рыба 
//  В качестве ключей в объекте можно использовать любые строки, даже строки с пробелами. С точечной нотацией такие свойства прочитать не получится, а со скобочной — без проблем.


// Свойства объектов можно не только читать, но и переопределять, как и обычные переменные. Вернёмся к объекту кота.
var cat = {
   name: 'Мяут',
   age: 5
};
cat.name = 'Рокки'; // Заменили снаружи значение свойства name
console.log(cat.name); // Выведет в консоль: Рокки
cat.age++; // Увеличили возраст кота на 1
console.log(cat.age) // Выведет в консоль: 6


// В объектах могут храниться любые типы данных, в том числе и функции. Такие свойства-функции называются методами объектов.
// Они вызываются так же, как и любые другие функции, через круглые скобки, а обращаемся мы к методам, как и к свойствам объекта. В итоге вызов метода записывается так: объект.метод().
var konsole = {
   log: function () {
      return 'Вывести в консоль';
   }
};
// Вызов функции log, y объекта konsole
konsole.log();


// Изнутри методов можно обращаться к свойствам и другим методам ЭТОГО ЖЕ объекта с помощью ключевого слова this. Оно указывает на текущий объект и называется контекстом вызова.
// Важная деталь: пока функция не вызвана, this не содержит никакого значения, контекст появляется только в момент вызова функции.
var cat = {
   name: 'Мяут',
   color: 'рыжий',
   age: 5,

   getGreeting: function () {
      return 'Мяу, привет! Меня зовут ' + this.name;
   }
};






// Ctrl+F - найти нужное слово. Ctrl+H	- заменить найденное слово другим.